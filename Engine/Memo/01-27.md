### 최종 파일 형태.
- 속성 > ConfigurationType(구성형식) > dll로 수정

```
.lib : 정적 라이브러리(static)
.dll : 동적 라이브러리(dynamic linking library)
둘다 모듈화를 하는 거고 실행이 목적이 아님.

둘 다 이진 코드인데, 사용하려면 명세가 있어야 해.
라이브러리는 두 가지 자료가 필요한데, `헤더파일과 lib/dll` 

링킹을 어떻게 하는거냐. dll이던 lib던 exe와 붙이려고 하는건데, 이진코드(exe)와 이진코드(lib 혹은 dll)를 연결함. 
linking을 실행 전에 할거냐 실행 후에 할거냐에 나뉘는데, lib는 exe를 만들 때 합쳐져서 만들어진다. 그래서 정적이라고 한다.
(lib라는 것이 사라짐)

근데, dll은 실행할 때 붙음. 즉, 배포할 때도 있어야 함. 그래서 동적이라고 하는 것.
-> dll은 실행 중에 붙기 때문에 배포할 때 꼭 필요하다.

근데 만약 라이브러리가 커진다면 exe자체가 커지는 상황이 발생하기 때문에 프로그램 덩치가 커짐.
정적이 좋은 건 알겠으나 용량이 커진다는게 문제.

dll은 동적으로 붙여서 메모리가 별도 공간으로 들어감. exe를 실행할 때는 요만큼, dll에서 요만큼 자리를 잡음.
실행중에 exe에서 dll로 왔다갔다함.
하지만, 공간을 나눌 수 있기 때문에 운영체제 입장에서 한 덩어리로 올리지 않기 때문에 관리하는 측면에서 더 낫다.
근데 dll은 동적으로 하기 때문에 시간이 더 걸림. 즉, 느림. 하지만 용량을 분리할 수 있기 때문에 많이 쓰임.
오래 걸리는 이유는 os를 거쳐가야 하는 자원이기 떄문에.

가능만하다면, 정적 라이브러리가 더 좋음. 배포시에는 사용자에게 dll파일을 보일 필요가 없다.

```

- dll이기 때문에 Main.cpp파일이 필요 없어짐. 있던 없던 상관없어짐. 지우진 않겠으나 필요 없음.
	-> 리빌드.
- 최상위 디렉토리에 Includes > Engine 폴더를 두 개 추가하고, 필요한 헤더만 필터링 해서 옮겨야 함.
	- 헤더만 다 넣어주면 됨. cpp인 몸체는 굳이 안보여줘도 됨.

- 최상위 디렉토리 Library > Engine > x64 > Debug 폴더 다 만들어서 안에 Engine.dll파일을 만들어준다.

- dll을 exe와 웬만하면 붙어야 함. 근데 그걸 없애기 위해서는 LoadLibraryA 함수를 사용하면 되는데 함수마다 해줘야 해서 굉장히 귀찮은 작업.
	-> 

---

- cmd 명령어 
	- xcopy 복사하기 명령어. 
	- xcopy [무엇을] [어디에] \e 덮어써라. \y 더이상 묻지마.

### 빌드 이벤트

- 프로젝트 속성 > Build Events들 적용.

###

xcopy ..\Library\Engine\$(Platform)\$(Configuration)\Engine.dll $(OutDir)\ /e /y

- .h마다 클래스와 클래스명 사이에 `__declspec(dllexport)` 이걸 추가한다.
(관련 링크 : https://learn.microsoft.com/ko-kr/cpp/build/exporting-from-a-dll-using-declspec-dllexport?view=msvc-170)
- 클래스는 dll로 만들 때 dll밖에서 접근해야 하는 주체야라는걸 알려줌.

- 템플릿은 dll못넘어가게 해줌. 허용은 해주는데 그냥 넘어가줄게.
- dll넘어갈 때 템플릿을 안쓰는게 1번.

- 경고 나오는 메시지 C4251에 대해서만 꺼버릴 수 있음. Engine.lib도　넘겨야　함．

- `__declspec(dllexport)` 을 붙이면 .lib파일도 같이 뽑혀나옴.-> dll에 대한 실체 내용들이 담겨있음.

- 참고로 언리얼 엔진에서는 이 매크로를 어떻게 사용하냐면, 내가 만든 파일에 export를 붙이게끔 하고 있음.
즉, 내가 만든 파일을 dll로 불러와서 게임을 실행시키는 방식.